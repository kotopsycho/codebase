# C++ Primer

[TOC]


## 序章

### 第一章  开始

每一个C++程序都包含一个或多个函数，其中一个个必须命名为main，操作系统通过调用main来运行C++程序。

即 main 与 function*

```C++
int main()
{
    return 0;
}
```

大多数系统中，main的返回值用来指示状态，0表示成功，非0的返回值含义由系统定义，通常用来指出错误。

程序源文件命名约定：不同编译器使用不同后缀名约定，常见的有：.cc、.cxx、.cpp、.cp、.c。。

```c++
/*
 *多
 *行
 *注
 *释
 */
//单行注释
```

注释界定符不能嵌套





## C++基础

### 第二章 变量和基本类型

#### 基本内置类型

##### 算术类型

C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。

算术类型：

| 类型      | 含义        | 最小尺寸     |
| :-------- | :---------- | :----------- |
| bool      | 布尔类型    | 未定义       |
| char      | 字符        | 8bit         |
| wchar_t   | 宽字符      | 16bit        |
| char16_t  | Unicode字符 | 16bit        |
| char32_t  | Unicode字符 | 32bit        |
| short     | 短整型      | 16bit        |
| int       | 整型        | 16bit，2Byte |
| long      | 长整型      | 32bit        |
| long long | 长整型      | 64bit        |

| 类型        | 含义           | 最小尺寸     |
| :---------- | :------------- | :----------- |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 拓展精度浮点数 | 10位有效数字 |

布尔类型的取值是真或假，即true or false。

大多数计算机以2的整数次幂个bit作为块来处理内存，可寻址的最小内存块称作“字节（byte）”，储存的基本单位成为“字（word）”，通常为几个字节构成。在C++中，一个字节至少要容纳机器基本字符集中的字符。

大多数机器的byte由8bit构成，word则由32bit或64bit构成，也就是4或8byte。

##### 类型转换

非0值转为布尔，真，0转为布尔，假；

false布尔值转为算术类型为0，true为1；

浮点数转整型，仅保留小数点前；

整数转浮点，小数部分为0，如果该整数超过了浮点数的容量，精度可能有损失；

给无符号整型赋值超其范围的数n，则转型后初始值为n mod 范围，例：-1转unsigned char，结果为255；

给有符号整型赋值超出其范围的数，结果是未定义的，程序可能继续工作、可能崩溃、可能生成垃圾数据。

> 避免无法预知和依赖于现实环境的行为，
>
> 无法预知会导致程序在未知情况发生错误
>
> 依赖现实环境则会导致程序具有“不可移植性”

##### 含有无符号类型的表达式

在无符号类型和有符号类型共同出现的表达式里，有符号数会自动转型成为无符号数。因此：

> 切勿混用带符号类型和无符号类型！

混用的效果如下：

```c++
#include<iostream>

int main()
{
	int a;
	unsigned int b;
	a = -1;
	b = 0;
	std::cout << a + b;
	return 0;
}
//output：4294967295，即32位最大正整数，0xFFFFFFFF,也可以表示ip地址中的255.255.255.255
```

##### 转义序列

```
\n \t \a \v 
\b \" \\ \? 
\' \r \f
分别为：
换行符，横向制表符，响铃符，纵向制表符
退格符，双引号，反斜线，问号
单引号，回车符，进纸符
```

##### 字面值常量

形如24的值被称作字面值常量。

```c++
20 //十进制
024//八进制，0开头
0x4//16进制，0x开头
3.14159
3.454E0
0.
0E0
.001
//以上全部是double，默认都是double，显式的使用f后缀来使其成为float
'a'    //字符字面值
"abc"  //字符串字面值
//以下为分多行写的字符串字面值
"ab" "cd"//其实是 abcd
"ab"
"cd"	//其实是 abcd
/*如果两个字符串字面值
 *位置紧邻
 *仅由空格
 *或缩进
 *或换行符
 *分隔时，则它们实际上为一个整体
```

##### 指定字面值的类型

通过给字面值添加前后缀来指定字面值的类型

| 前缀 | 含义                          | 类型     |
| ---- | ----------------------------- | -------- |
| u    | Unicode16字符                 | char16_t |
| U    | Unicode32字符                 | char32_t |
| L    | 宽字符                        | wchar_t  |
| u8   | UTF-8（仅用于字符串字面常量） | char     |

| 整型后缀       | 最小匹配类型 |
| -------------- | ------------ |
| u or U         | unsigned     |
| l or L         | long         |
| ll or LL       | long long    |
| **浮点型后缀** | **类型**     |
| f or F         | float        |
| l or L         | long double  |

> 在使用长整型或拓展精度字面值的时候，应该使用大写L而不是小写的l，因为小写l与数字1容易造成混淆。

##### 其它类型的字面值

布尔类型字面值：true、false

指针字面值：nullptr

#### 变量

##### 变量定义

类型说明符 跟 变量名列表，名以逗号分隔，分号结束。

> 注意区分变量初始化和赋值的含义

初始化四种方式

```c++
int i = 1;
int i = {1};
int i{1};
int i(1);
//区别在于，假设有以下情况
double j = 3.14;

int a = j;//转换执行，丢失了小数部分的值

int b{j};//转换不执行，存在丢失信息的风险（大转小）便会不执行

```

没有指定初值则会使变量被默认初始化。

##### 变量的声明和定义

C++支持**分离式编译**，程序可以分割为多个文件，每个文件可以分别单独编译。

为了支持分离式编译，要区分对变量的**声明**和**定义**。

```c++
extern int i; //声明
int j;		 //定义
extern double pi = 3.14; //定义
```

> 变量**能且仅能**被定义**一次**；但是可以在需要使用的地方声明多次。

#### 复合类型

##### 引用 reference

```c++
int val;
int &refval = val;  //创建了一个对val的int型的引用
int &referval2;     //报错，引用必须被初始化
```

> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字

对引用对象的操作都是在与之绑定的对象上进行的，引用只能引用一个对象，因为10，3.14这种字面值不是对象，引用也不是对象，所以不能写出如下的代码：

```c++
int val;
int &refval = val;       //创建了一个对val的int型的引用
int &referval2 = 10;     //报错，引用必须引用对象
int &referval3 = refval  //报错，引用必须引用对象
```

##### 指针 pointer

指针是用来存放对象地址的类型。

指针的值应属下列四种状态之一：

1.指向一个对象

2.指向紧邻对象所占空间的下一个位置

3.空指针，意味着指针没有指向任何对象

4.无效指针，也就是上述情况之外的其他值

```c++
int a = 5;
int *p;           //
p = &a;			 //通过取址符给指针赋值
std::cout << *p;  //通过解引用符号*来访问已经指向对象的指针
```

指针是一种对象，所以可以有指针的引用。也可以有指针的指针。

##### const限定符

使用const限定符修饰的变量必须被初始化，任何试图为const对象赋值的行为都会报错。

> 要注意，int const * 和 const int *的作用是一致的，都是创建了一个指针，该指针类型为**常量整数**。
>
> 要想声明/定义一个不可更改的指向整型类型的指针，应使用int * const。
>
> 从上面的区别可以看出，const默认修饰其左边的东西，若左边没有东西才修饰右边的东西。



### 第三章 字符串、向量和数组

#### 标准库类型string

其定义在命名空间std中，使用string类型必须先包括头文件string。

#### 定义和初始化string对象

```c++
string s1;			//默认初始化，为空串
string s2 = s1;		//s2是s1的副本
string s2(s1);		//s2是s1的副本
string s3 = "hiya"; //s3是字符串字面值的副本
string s3("haya");  //s3是字符串字面值的副本
string s4(5,'c');	//s4的内容是ccccc
```

##### 直接初始化和拷贝初始化

```c++
string s5 = "hiya";  //拷贝初始化
string s6("hiya");	 //直接初始化
string s7(5,'a');	 //直接初始化
string s8 = string(10,'a'); //拷贝初始化，从效率和可读性上来说，应避免这种方式。
```

#### string的操作

##### 读写string

可以使用流式读写string，如下：

```c++
string s1,s2 = "456";
cin >> s1;
cout << s2;
getline(cin,s1);//读取一整行，读入的包括换行符
```

##### empty与size

empty返回一个字符串是否为空的布尔值。

size函数返回string对象的长度（即string对象中字符的个数）。注意，此处的字符个数不包括'\0'，无论你是否显式的添加到字符串末尾，c++都会为你确保字符串以'\0'结尾。具体情况如下：

```c++
string s1,s2,s3;
s1 = "a";
s2 = "a\0";
cout << sizeof(s1) << ' ' << sizeof(s2) << ' ' << sizeof(s3) << endl;
cout << size(s1) << ' ' << size(s2) << ' ' << size(s3) << endl;
/*
output：
28 28 28
1 1 0
*/
//注意，sizeof的实现效果根据自身机器和编译器的不同所带来的效果不同。此处仅作提及，并不探讨sizeof的作用。
```

size函数的返回值**并不是！！！**int型或者unsigned 。而是一个string::size_type类型的值。显而易见，size_type是在类string中定义的。在C++11之后，可以使用auto或decltype来交由编译器来推断变量类型。

由于size返回的是一个无符号整数，所以在size函数参与的表达式里，如果出现了int，则int会自动的转换为unsigned（参考第二章无符号类型的特点）。在转换时，若出现负数，则会转为一个较大的正值。如下:

```c++
int n;
string s1 = "aw856d456aw4d56a";
s1.size() < n;
/*
若n可能会出现负值，则会导致在比较时n被转换为一个较大的正整数值，即从int型转为unsigned；此时，一般能见到的字符串对应这个表达式的值都将为真，可能为带来不必要的麻烦。
*/
```

> 所以切记，在使用string.size()时，不要再使用int类型了，可能会导致隐式的类型转换而带来不必要的错误。
>
> 推荐使用auto或unsigned。（个人习惯，并没有什么特殊好处）

##### 字符串字面值与字符串的加法

在进行字符串与字符串字面值的加法时，一定要确保加号 + 的两边**至少有一个**的运算对象类型为string。

```c++
string s1,s2,s3;
s1 = "asdaw";
s2 = "dawdf";
s3 = "wfaf5";
//开始进行加法
string s4 = s1 + s2;//正确，两个皆为string
string s5 = s1 + "wdawf";//正确，有一个string
string s6 = "wdada" + "g4545daw";//错误，不能让两个字面值相加
string s7 = s1 + "wdad" + s2 + "sdaw" + s3 + "\n\0";//正确，至少有一个string
```

> 字符串与字符串字面值具有区别是因为：
>
> 1.某些历史原因
>
> 2.c++要兼容c语言特性

##### 访问字符串中的部分字符

下标运算符（ [ ] ）接受的参数是**string::sizetype**类型的值，这个参数表示要访问的字符的位置，返回的是该位置上的字符的引用。下标从0计起。

> string对象的下标必须大于等于0而小于s.size()。
>
> 使用超出此范围的下标引起的结果是不可预知的，因此，使用下标访问空串也会引起不可预知的结果。
>
> c++标准并不会检查下标的合法性，所以超出范围带来的后果是未知的。

**访问字符前必须检查是否为空串！！！**

```c++
if(!s.empty())	//一定要检查是否为空串
{
	cout<<s[n]<<endl;
}
```

#### 标准库类型vector

标准库类型vector表示对象的集合，其中所有对象**类型都相同**。vector也可被称作**容器**。要想使用vector，则需要使用下列语句：

```c++
#include <vector> 
using std::vector;
```

##### 定义和初始化vector对象

```c++
vector<T> v1;
vector<T> v2(v1);
vector<T> v2 = v1;
vector<T> v3(n, val);
vector<T> v4(n);
vector<T> v5{a, b, c...};
vector<T> v6 = {a, b, c...};
```

##### vector中的操作

> 编程建议：for循环语句体内部**不应该**改变其遍历序列的大小。



| 操作                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| v.push_back(val)     | 从尾部向容器内添加元素                                       |
| v.empty()            | 检查容器是否为空，返回bool值                                 |
| v.size()             | 返回容器大小，返回vector定义的size_type                      |
| v[n]                 | 返回下标处元素的引用                                         |
| v1 = v2              | v1获得v2内所有元素的拷贝                                     |
| v1 = {a, b, c... }   | v1获得列表内所有元素的拷贝                                   |
| v1 != v2 或 v1 == v2 | 当且仅当数量相同，且同位置处的元素值都相同时取==的true，其余为!=的true |

> 容器只能用push_back添加元素，不能用下标来添加，下标只能用来**访问**那些**已有**的元素。

#### 迭代器

使用下标可以来访问字符串的字符，vector的元素，但是c++中，标准库中支持下标运算符的容器只占少数，但所有的标准库容器都可以使用迭代器。

##### 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有begin和end成员。

```c++
//使用auto来交由编译器确定迭代器的类型
auto b = v.begin();
auto e = v.end();
//b表示v的第一个元素，e表示v的最后一个元素的**下一个**位置
```

> 如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。
>
> （尾后指end返回的是一个本不存在的尾部的后面的迭代器，仅用来标记我们处理完容器中的所有元素）

##### 迭代器运算符

| 运算           | 含义                                                   |
| -------------- | ------------------------------------------------------ |
| *iter          | 返回迭代器iter所指元素的**引用**                       |
| iter->mem      | 解引用iter并获取该元素名为mem的成员，等价于(*iter).mem |
| ++iter         | 令iter指示容器中的下一个元素                           |
| --iter         | 令iter指示容器中的上一个元素                           |
| iter1 == iter2 | 判断俩迭代器是否指向同一个元素或指向同一个尾后迭代器   |
| iter1 != iter2 | 与上反之                                               |

##### 关于迭代器的类型

一般情况下其实无需明确知道迭代器的类型，使用auto交由编译器处理即可。实际情况下，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型。

```c++
vector<int>::iterator it;            //it能读写vector<int>的元素
string::iterator it2;                //it2能读写string对象中的字符

vector<int>::const_iterator it3;	//it3只能读的元素，不能写元素
string::const_iterator it4;         //it只能读字符，不能写字符
```

> 在使用迭代器的循环体中，千万不要向迭代器所属的容器内添加元素

##### 迭代器的运算

迭代器加减整数仍得到一个迭代器，该迭代器指示的新位置与原来相比向尾/头移动了该整数个元素。

两迭代器相减可以得到他们的距离。

两迭代器可以用大于、小于、大于等于等关系运算符，其中指向元素位置靠头的小于指向元素位置靠尾的。

#### 数组

##### 数组初始化

不能通过其他数组拷贝复制初始化数组。

初始化方式与c无太大区别。

#### 数组和指针

很多用到数组名的地方，编译器都会将其替换成指向首元素的指针。

##### 指针也是迭代器

可以通过指针的自增自减运算符，来访问数组的前后元素。

```c++
int ia[] = {1,2,3,4,5,6,7,8,9,10};
int *beg = begin(ia);
int *last = end(ia);
//因为数组并不是类，所以不能使用xx.begin()这种形式，数组本身作为参数调用c++11新标准引入的函数


//寻找第一个负值元素，如果检查完则循环结束
while(beg != last && *beg >= 0)
	++beg;
```



### 第四章 表达式

基本知识，不再赘述，此处只讲其中几种。

#### 位运算符

| 运算符 | 功能     |
| ------ | -------- |
| ~      | 位求反   |
| <<     | 左移     |
| >>     | 右移     |
| &      | 按位与   |
| ^      | 按位异或 |
| \|     | 按位或   |

位运算符优先级低于算数运算符，但高于关系运算符。

#### sizeof运算符

sizeof运算符返回一个表达式或一个类型名字所占的**字节**数。sizeof满足右结合律，所得的值是一个size_t类型。（size_t类型是一种**机器相关**的**无符号类型**）

1.对char或类型为char的表达式执行sizeof运算，结果为1.

2.对引用类型执行sizeof运算得到被引用对象本身所占空间大小。

3.对指针执行sizeof运算，得到指针所占空间大小。

4.对解引用指针执行sizeof运算，得到指向对象的类型所占空间大小，指针不需要有效。

5.对数组进行sizeof运算得到整个数组所占空间大小。

6.对string或vector对象执行sizeof运算，只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

#### 逗号运算符

逗号运算符含有两个运算对象，按照从左到右的顺序依次求值，对于逗号运算符，先求出左侧表达式的值，然后丢弃掉，逗号运算符的真正结果是右侧表达式的值。

#### 类型转换

##### 隐式转换

隐式转换发生在如果两个类型可以互相转换（相互转换并不代表不会损失精度）的情况下，在表达式里自动执行，无需程序员介入。

常见的有比int小的类型在运算中被升格至int，条件表达式中非布尔值被转换成布尔值，数组名转换成指针等

##### 显示转换

显示转换有四种。

**static_cast、dynamic_cast、const_cast、reinterpret_cast**。

转换具有以下形式：

cast_name<type>（expression）；

其中，dynamic_cast放到19章讲。

###### static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

```c++
double i = 3.14;
int j = 3;
double x = static_cast<double>(j) / i;
```

###### const_cast

只能改变底层const，去掉对象的const性质，但是对一个去掉const后的常量的写操作是未定义后果的。具体型位在第六章的重载函数讲。

###### reinterpret_cast

使用具有危险，依赖于机器实现。

###### 旧式的强制类型转换（c语言风格）

```c++
//如下
double i = 3.14;
int j = (int)i;
```

这类强制转换与reinterpret_cast类似，所以不建议使用。

> 建议：避免强制类型转换，其干扰了正常的类型检查，尤其是reinterpret_cast。多处使用类型转换意味着设计存在某种缺陷。



### 第五章 语句

#### 简单语句

表达式语句：表达式+分号

空语句：单独一个分号

#### 复合语句

由花括号括起来的语句块（可以为空）。复合语句也被称作块（block）

#### 条件语句循环语句略过

#### try语句块和异常处理

异常处理包括：

throw表达式：异常检测部分用throw表达式来表示它遇到了无法处理的问题。我们说throw**引发**了异常

try语句块：异常处理部分用try语句块处理异常。以try开始，并以一个或多个catch子句结束。

一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。

##### throw表达式

throw表达式包含关键字throw和紧随其后的表达式，其中表达式的类型就是抛出的异常类型。throw表达式通常后面紧跟一个分号，从而构成一条表达式语句。

##### try语句块

try语句块通常的语法形式是：

```c++
try{
	//some statements
}catch (exception-declaration){
	//handle statements
}catch (exception-declaration){
	//handle statements
}//...
```

try语句块内声明的变量，在catch子句内也是无法访问的。

#### 标准异常

c++标准定义了一组类，用于报告标准库函数遇到的问题。这些异常也可以在用户编写的程序中使用，它们分别定义在4个头文件中：

execption头文件定义了最通用的异常类exception。他只报告异常的发生，不提供任何信息。

stdexcept头文件定义了几种常用的异常类，将在下面用表展开叙述。

new头文件定义了bad_alloc异常类型，将在12章讲解。

type_info头文件定义了bad_cast异常类型，将在19章讲解。

stdexcept定义的异常类型：

| 异常名           | 释义                                           |
| ---------------- | ---------------------------------------------- |
| exception        | 最常见的问题                                   |
| runtime_error    | 只有在运行时才能检测到的错误                   |
| range_error      | 运行时错误：生成结果超出了有意义的值域范围     |
| overflow_error   | 运行时错误：计算上溢                           |
| underflow_error  | 运行时错误：计算下溢                           |
| logic_error      | 程序逻辑错误                                   |
| domain_error     | 逻辑错误：参数对应的结果值不存在               |
| invalid_argument | 逻辑错误：无效参数                             |
| length_error     | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
| out_of_range     | 逻辑错误：使用一个超出有效范围的值             |



### 第六章 函数

#### 函数基础

典型的函数定义包括：返回类型，函数名，参数表以及函数体。

函数调用的基本过程：实参初始化形参，主调函数将控制权交给被调用函数。执行结束后，return值并且把控制权交回给主调函数。

函数的返回类型：函数的返回类型不能是数组和函数，但是可以是指向数组或函数的指针。

#### 局部对象

对象具有**生命周期**，而名字有**作用域**。

**对象的生命周期**是程序执行过程中该对象存在的一段时间。

**名字的作用域**是程序文本的一部分，名字在其中可见。

##### 自动对象

对于普通局部变量的对象，将在定义的块尾销毁。我们把只存在于块执行期间的对象成为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

##### 局部静态对象

有些时候，需要令局部变量的生命周期贯穿调用及调用结束之后，可以将局部变量定义成static从而获得这样的对象。

```c++
size_t count_calls()
{
	static size_t ctr = 0;
	return ++ctr;
}
int main()
{
	for(size_t i = 0; i != 10 ; i++)
		cout<< count_calls() << endl;
	return 0;
}
```

上面的程序将输出1到10的数字。

#### 参数传递

每次调用函数时，都会重新创建它的形参，并用传入的实参进行初始化。

##### const参数

当形参是const类型时，实参传入时会忽略掉其顶层const。如：形参定义为 const int a，调用时传入非const的，int型变量是可以的。

#### 函数指针

函数指针指向的是函数而非对象。指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定，与函数名无关。下面是如何定义一个函数指针。

```c++
//函数声明
bool lengthCompare(const string &, const string &);
//函数指针定义
bool (*pf) (const string &, const string &);//未初始化
//给函数指针赋值
pf = lengthCompare;
pf = &lengthCompare;
/*
*pf两边的括号不能省略，否则*将会与bool结合，即：
bool* pf (const string &, const string &);
该语句声明了一个：返回指向bool类型的指针的，名为pf的，参数为const string &, const string &的，函数
*/
```

##### 使用函数指针

函数指针的使用如下：

```c++
bool lengthCompare(const string &, const string &);
bool (*pf) (const string &, const string &);
pf = lengthCompare;

//下列调用是等价的
bool b1 = pf("hello", "goodbey");
bool b2 = (*pf)("hello", "goodbey");
bool b3 = lengthCompare("hello", "goodbey");
```

不同类型的函数指针**不存在**转换规则。

对重载函数使用指针时，指针类型必须**精确**匹配某一个重载函数。即返回值和参数类型必须完全一致。

##### 函数指针作为形参或返回值

函数不能直接作为参数，但是指向函数的函数指针可以作为函数的参数。

同样的，函数不能直接作为返回值，但是可以返回指向函数的指针。

##### 使用auto和decltype来确定函数指针类型

```
string::sizetype sumLength(const string &, const string &);
string::sizetype largerLength(const string&, const string&);
//两函数返回类型和参数都一致，所以函数的类型是一样的，可以使用同一类型的函数指针。
decltype(sumLength) *getFcn(const string &);
//使用decltype作用于某个函数时，他返回函数类型而非指针类型，所以要在getFcn前显式的添加*来表示指针。
```



### 第七章 类






## C++标准库

### 第八章 IO库

### 第九章 顺序容器
### 第十章 泛型算法

### 第十一章 关联容器
### 第十二章 动态内存


## 类设计者的工具

### 第十三章 拷贝控制
### 第十四章 重载运算与类型转换
### 第十五章 面向对象程序设计
### 第十六章 模板与泛型编程


## 高级主题

### 第十七章 标准库特殊设施
### 第十八章 用于大型程序的工具
### 第十九章 特殊工具与技术